// !!!This plugin has been deprecated!!!
// !!!Use the PHP version instead!!!
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

// Generator is the type whose methods generate the output,
// stored in the associated response structure.
type Generator struct {
	*bytes.Buffer

	Request        *plugin.CodeGeneratorRequest  // The input.
	Response       *plugin.CodeGeneratorResponse // The output.
	indent         string
	clientTrait    string
	requireName    string
	requireVersion string
	composerName   string
	Param          map[string]string
}

// New creates a new generator and allocates the request and response protobufs.
func New() *Generator {
	g := new(Generator)
	g.Buffer = new(bytes.Buffer)
	g.Request = new(plugin.CodeGeneratorRequest)
	g.Response = new(plugin.CodeGeneratorResponse)
	g.indent = ""
	g.clientTrait = "\\Lv\\Grpc\\CurlStubTrait"
	g.composerName = ""
	g.requireName = "lvht/grpc"
	g.requireVersion = "dev-master"

	return g
}

func getFilePath(p string, name string) string {
	var pp []string
	for _, part := range strings.Split(p, ".") {
		pp = append(pp, strings.Title(part))
	}

	p = filepath.Join(pp...)
	return p + string(os.PathSeparator) + name
}

func getNameSpace(p string) string {
	var pp []string
	for _, part := range strings.Split(p, ".") {
		pp = append(pp, strings.Title(part))
	}

	return strings.Join(pp, "\\")
}

// Error reports a problem, including an error, and exits the program.
func (g *Generator) Error(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protoc-gen-go: error:", s)
	os.Exit(1)
}

// Fail reports a problem and exits the program.
func (g *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("protoc-gen-go: error:", s)
	os.Exit(1)
}

func extractComments(file *descriptor.FileDescriptorProto) map[string]*descriptor.SourceCodeInfo_Location {
	comments := make(map[string]*descriptor.SourceCodeInfo_Location)
	for _, loc := range file.GetSourceCodeInfo().GetLocation() {
		if loc.LeadingComments == nil {
			continue
		}
		var p []string
		for _, n := range loc.Path {
			p = append(p, strconv.Itoa(int(n)))
		}
		comments[strings.Join(p, ",")] = loc
	}

	return comments
}

// In Indents the output one tab stop.
func (g *Generator) In() { g.indent += "    " }

// Out unindents the output one tab stop.
func (g *Generator) Out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[4:]
	}
}

func (g *Generator) generateComposer() {
	if g.composerName == "" {
		g.Fail("no client_name")
	}

	g.P("{")
	g.In()
	g.P(fmt.Sprintf("\"name\":\"%s\",", g.composerName))

	// debug repositories
	// g.P("\"repositories\":[{\"type\":\"path\",\"url\":\"/home/lvht/php/grpc\"}],")

	g.P("\"require\": {")
	g.In()
	g.P(fmt.Sprintf("\"%s\":\"%s\"", g.requireName, g.requireVersion))
	g.Out()
	g.P("},")
	g.P("\"autoload\": {")
	g.In()
	g.P("\"psr-0\": {")
	g.In()
	g.P("\"\": \".\"")
	g.Out()
	g.P("}")
	g.Out()
	g.P("}")
	g.Out()
	g.P("}")
}

func (g *Generator) generateInterface(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto, index int) {
	g.P("<?php")
	g.P("// Generated by the protocol buffer compiler.  DO NOT EDIT!")
	g.P("// source: " + file.GetName())
	g.P()
	g.P("namespace " + getNameSpace(file.GetPackage()) + ";")
	g.P()

	comments := extractComments(file)

	g.P("interface " + service.GetName() + "Service extends \\Lv\\Grpc\\Service")
	g.P("{")
	g.In()
	path := fmt.Sprintf("6,%d", index) // 6 means service.
	for i, method := range service.GetMethod() {
		if i > 0 {
			g.P()
		}

		_path := fmt.Sprintf("%s,2,%d", path, i) // 2 means method in a service.
		if loc, ok := comments[_path]; ok {
			g.P("/**")
			text := strings.TrimSuffix(loc.GetLeadingComments(), "\n")
			for _, line := range strings.Split(text, "\n") {
				g.P(" * ", strings.TrimPrefix(line, " "))
			}
			g.P(" */")
		}

		signature := fmt.Sprintf(
			"function %s(\\Lv\\Grpc\\Context $context, %s $request) : %s;",
			method.GetName(),
			getNameSpace(method.GetInputType()),
			getNameSpace(method.GetOutputType()))
		g.P(signature)
	}
	g.Out()
	g.P("}")
}

func (g *Generator) generateStub(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto, index int) {
	g.P("<?php")
	g.P("// Generated by the protocol buffer compiler.  DO NOT EDIT!")
	g.P("// source: " + file.GetName())
	g.P()
	g.P("namespace " + getNameSpace(file.GetPackage()) + ";")
	g.P()

	comments := extractComments(file)

	serviceName := service.GetName() + "Service"
	g.P("final class " + serviceName + "Stub implements " + serviceName)
	g.P("{")
	g.In()
	g.P("use " + g.clientTrait + ";")
	path := fmt.Sprintf("6,%d", index) // 6 means service.
	for i, method := range service.GetMethod() {
		g.P()
		_path := fmt.Sprintf("%s,2,%d", path, i) // 2 means method in a service.
		if loc, ok := comments[_path]; ok {
			g.P("/**")
			text := strings.TrimSuffix(loc.GetLeadingComments(), "\n")
			for _, line := range strings.Split(text, "\n") {
				g.P(" * ", strings.TrimPrefix(line, " "))
			}
			g.P(" */")
		}

		replyType := getNameSpace(method.GetOutputType())
		methodName := method.GetName()
		signature := fmt.Sprintf(
			"public function %s(\\Lv\\Grpc\\Context $context, %s $request) : %s",
			method.GetName(),
			getNameSpace(method.GetInputType()),
			replyType)
		g.P(signature)
		g.P("{")
		g.In()
		g.P("$reply = new " + replyType + "();")
		g.P()
		g.P("$this->send(\"/" + file.GetPackage() + "." + serviceName + "/" + methodName + "\", $context, $request, $reply);")
		g.P()
		g.P("return $reply;")
		g.Out()
		g.P("}")
	}
	g.Out()
	g.P("}")
}

func (g *Generator) generateService(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto, index int) {
	g.P("<?php")
	g.P("// Generated by the protocol buffer compiler.  DO NOT EDIT!")
	g.P("// source: " + file.GetName())
	g.P()
	g.P("namespace " + getNameSpace(file.GetPackage()) + ";")
	g.P()

	serviceName := service.GetName()
	g.P("trait " + serviceName + "ServiceTrait")
	g.P("{")
	g.In()
	g.P("final public function getMethods()")
	g.P("{")
	g.In()
	g.P("return [")
	g.In()
	for _, method := range service.GetMethod() {
		methodName := method.GetName()
		g.P("\"/" + file.GetPackage() + "." + serviceName + "Service/" + methodName + "\" => \"do" + methodName + "\",")
	}
	g.Out()
	g.P("];")
	g.Out()
	g.P("}")
	g.P()
	g.P("final public function newContext() : \\Lv\\Grpc\\Context")
	g.P("{")
	g.P("    throw new \\RuntimeException(__METHOD__.' can only called in client');")
	g.P("}")
	g.P()
	g.P("final public function getLastErrno()")
	g.P("{")
	g.P("    throw new \\RuntimeException(__METHOD__.' can only called in client');")
	g.P("}")
	g.P()
	g.P("final public function getLastError()")
	g.P("{")
	g.P("    throw new \\RuntimeException(__METHOD__.' can only called in client');")
	g.P("}")
	g.P()
	for _, method := range service.GetMethod() {
		g.P("final public function do" + method.GetName() + "(\\Lv\\Grpc\\Context $context, $data)")
		g.P("{")
		g.In()
		replyType := getNameSpace(method.GetInputType())
		g.P("$request = new " + replyType + ";")
		g.P()
		g.P("if ($context->getMetadata('content-type') === 'application/grpc+json') {")
		g.P("    $request->mergeFromJsonString($data);")
		g.P("} else {")
		g.P("    $request->mergeFromString($data);")
		g.P("}")
		g.P()
		g.P("return $this->" + method.GetName() + "($context, $request);")
		g.Out()
		g.P("}")
	}
	g.Out()
	g.P("}")
}

// CommandLineParameters breaks the comma-separated list of key=value pairs
// in the parameter (a member of the request protobuf) into a key/value map.
// It then sets file name mappings defined by those entries.
func (g *Generator) CommandLineParameters(parameter string) {
	g.Param = make(map[string]string)
	for _, p := range strings.Split(parameter, ",") {
		if i := strings.Index(p, "="); i < 0 {
			g.Param[p] = ""
		} else {
			g.Param[p[0:i]] = p[i+1:]
		}
	}

	for k, v := range g.Param {
		switch k {
		case "composer_name":
			g.composerName = v
		}
	}
}

// P prints the arguments to the generated output.  It handles strings and int32s, plus
// handling indirections because they may be *string, etc.
func (g *Generator) P(str ...interface{}) {
	if len(str) > 0 {
		g.WriteString(g.indent)
	}

	for _, v := range str {
		switch s := v.(type) {
		case string:
			g.WriteString(s)
		case *string:
			g.WriteString(*s)
		case bool:
			fmt.Fprintf(g, "%t", s)
		case *bool:
			fmt.Fprintf(g, "%t", *s)
		case int:
			fmt.Fprintf(g, "%d", s)
		case *int32:
			fmt.Fprintf(g, "%d", *s)
		case *int64:
			fmt.Fprintf(g, "%d", *s)
		case float64:
			fmt.Fprintf(g, "%g", s)
		case *float64:
			fmt.Fprintf(g, "%g", *s)
		default:
			g.Fail(fmt.Sprintf("unknown type in printer: %T", v))
		}
	}
	g.WriteByte('\n')
}

// GenerateAllFiles generates the output for all the files we're outputting.
func (g *Generator) GenerateAllFiles() {
	for _, file := range g.Request.GetProtoFile() {
		for i, service := range file.GetService() {
			g.Reset()
			g.generateInterface(file, service, i)
			g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
				Name:    proto.String(getFilePath(file.GetPackage(), service.GetName()) + "Service.php"),
				Content: proto.String(g.String()),
			})

			g.Reset()
			g.generateStub(file, service, i)
			g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
				Name:    proto.String(getFilePath(file.GetPackage(), service.GetName()) + "ServiceStub.php"),
				Content: proto.String(g.String()),
			})

			g.Reset()
			g.generateService(file, service, i)
			g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
				Name:    proto.String(getFilePath(file.GetPackage(), service.GetName()) + "ServiceTrait.php"),
				Content: proto.String(g.String()),
			})
		}
	}

	g.Reset()
	g.generateComposer()
	g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
		Name:    proto.String("composer.json"),
		Content: proto.String(g.String()),
	})
}

func main() {
	g := New()

	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		g.Error(err, "reading input")
	}

	if err := proto.Unmarshal(data, g.Request); err != nil {
		g.Error(err, "parsing input proto")
	}

	if len(g.Request.FileToGenerate) == 0 {
		g.Fail("no files to generate")
	}

	g.CommandLineParameters(g.Request.GetParameter())
	g.GenerateAllFiles()

	// Send back the results.
	data, err = proto.Marshal(g.Response)
	if err != nil {
		g.Error(err, "failed to marshal output proto")
	}
	_, err = os.Stdout.Write(data)
	if err != nil {
		g.Error(err, "failed to write output proto")
	}
}
