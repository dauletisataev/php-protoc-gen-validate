(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: person.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Validate = Validate
end
(**/**)
module Examplepb = struct
  module rec Person : sig
    module rec Location : sig
      val name': unit -> string
      type t = { lat: float; lng: float } 
      val make : ?lat:float -> ?lng:float -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { id: int; email: string; name: string; home: Person.Location.t option } 
    val make : ?id:int -> ?email:string -> ?name:string -> ?home:Person.Location.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec Location : sig
      val name': unit -> string
      type t = { lat: float; lng: float } 
      val make : ?lat:float -> ?lng:float -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "person.examplepb.Person.Location"
      type t = { lat: float; lng: float }
      let make =
        fun ?lat ?lng () -> 
        let lat = match lat with Some v -> v | None -> 0. in
        let lng = match lng with Some v -> v | None -> 0. in
        { lat; lng }
      
      let to_proto =
        let apply = fun ~f:f' { lat; lng } -> f' [] lat lng in
        let spec = Runtime'.Serialize.C.( basic (1, double, proto3) ^:: basic (2, double, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions lat lng -> { lat; lng } in
        let spec = Runtime'.Deserialize.C.( basic (1, double, proto3) ^:: basic (2, double, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "person.examplepb.Person"
    type t = { id: int; email: string; name: string; home: Person.Location.t option }
    let make =
      fun ?id ?email ?name ?home () -> 
      let id = match id with Some v -> v | None -> 0 in
      let email = match email with Some v -> v | None -> {||} in
      let name = match name with Some v -> v | None -> {||} in
      { id; email; name; home }
    
    let to_proto =
      let apply = fun ~f:f' { id; email; name; home } -> f' [] id email name home in
      let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> Person.Location.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions id email name home -> { id; email; name; home } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> Person.Location.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
end